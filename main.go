package main

import (
	"bytes"
	"fmt"
	"log"
	"syscall/js"

	"golang.org/x/crypto/openpgp"
	"golang.org/x/crypto/openpgp/armor"
)

var (
	version = "unknown"
	pgpInst *pgp
)

type pgp struct {
	Type   string
	Header map[string]string

	EntityList openpgp.EntityList
}

// LoadArmoredKey load a armored PGP key into entity list
func (p *pgp) LoadArmoredKey(k string) (err error) {
	p.EntityList, err = openpgp.ReadArmoredKeyRing(bytes.NewBufferString(k))
	return err
}

// Encrypt encrypts plaintext and converts to ASCII Armor
func (p *pgp) Encrypt(pt []byte) (*bytes.Buffer, error) {

	b := new(bytes.Buffer)

	w, err := armor.Encode(b, p.Type, p.Header)
	if err != nil {
		return b, err
	}

	t, err := openpgp.Encrypt(w, p.EntityList, nil, nil, nil)
	if err != nil {
		return b, err
	}

	_, err = t.Write(pt)
	if err != nil {
		return b, err
	}

	t.Close()
	w.Close()

	return b, nil
}

func loadArmoredKey(i []js.Value) {
	err := pgpInst.LoadArmoredKey(i[0].String())
	if err != nil {
		log.Fatal(err)
	}
	log.Println("Armored key loaded successfully")
}

func encryptMessage(i []js.Value) {
	msg, err := pgpInst.Encrypt([]byte(i[0].String()))
	if err != nil {
		log.Fatal(err)
	}
	js.Global().Set(i[1].String(), js.ValueOf(msg.String()))
	log.Println("Message successfully encrypted")
}

func registerFunctions() {
	js.Global().Set("loadArmoredKey", js.NewCallback(loadArmoredKey))
	js.Global().Set("encryptMessage", js.NewCallback(encryptMessage))
}

func main() {
	c := make(chan struct{}, 0)

	pgpInst = &pgp{
		Type: "PGP MESSAGE",
		Header: map[string]string{
			"Comment": fmt.Sprintf("Generated by morphy2k/wasm-pgp %s", version),
		},
	}

	registerFunctions()

	log.Println(fmt.Sprintf("WasmPGP %s initialized", version))

	<-c
}
